<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 时光 &#149 印记]]></title>
  <link href="http://erikge.com/categories/ios/atom.xml" rel="self"/>
  <link href="http://erikge.com/"/>
  <updated>2014-06-25T18:26:36+08:00</updated>
  <id>http://erikge.com/</id>
  <author>
    <name><![CDATA[erik ge]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift语法糖]]></title>
    <link href="http://erikge.com/articles/SwiftSyntax"/>
    <updated>2014-06-20T17:34:28+08:00</updated>
    <id>http://erikge.com/articles/SwiftSyntax</id>
    <content type="html"><![CDATA[<p>Swift中引入了很多高级语言的特性，如闭包、命名空间、泛型、强类型（同时拒绝阴式类型转换）、多个返回值（元组）等等，这些高级的语法糖用好了可以极大提升工作效率，用不好也是语法坑。</p>

<!--more-->

<h2 id="闭包">闭包</h2>

<p>暂时可以把闭包理解为是函数，包括匿名函数。函数在Swift里变身一等公民，这样就有了很多好玩的特性。</p>

<ol>
<li><p>函数可以嵌套，内部函数可以访问外部函数的变量
&ldquo;` python
func sum(num:Float&hellip;) -&gt; Float {
var sum:Float = 0;</p>

<p>func add(v:Float){
    sum += v
}</p>

<p>for n in num {
    add(n)
}
return sum
}</p></li>
</ol>

<p>sum()
sum(12, 13, 14)
sum(1, 32,13,3)
<code>
2. 函数可以传递，可以作为参数或返回值
</code> python
func add(a:Int,b:Int) -&gt; Int {
    return a+b;
}</p>

<p>func copy(x:Int, y:Int, method:(Int,Int)-&gt;Int) -&gt; Int{
    var ret = 0
    ret = method(x,y)
    return ret
}</p>

<p>copy(3,4,add)
<code>
3. 函数可以匿名，变身匿名闭包，这时可以通过位置访问参数，或者通过in给参数个名字
</code> python
copy(7,2){return $0+$1}</p>

<p>copy(3,9,{
    (a:Int,b:Int)-&gt;Int in
    return a+b
})
&rdquo;`</p>

<h2 id="枚举">枚举</h2>

<p>语法示例如下，当类型已知时，可以直接通过.Apple这种方式来使用；类型未知时，通过全名Fruit.Apple来使用。
另外，如果frowRaw()的值为声明，不想C++一样可以继续使用，而是返回nil。Swift里要明确声明，减少潜规则，鼓掌<sup>_^</sup></p>

<p>这里给枚举附的值叫做原始值，原始值对所有的实例都是相同的。原始值工作的像C++、Java等语言的枚举值一样。后面我们会看到一个好玩的。
&ldquo;` python
enum Fruit:Double {
    case Apple = 7
    case Orange, Banana, Peach</p>
<div class="highlight"><pre><code class="text">func toString() -&gt; String {
    switch (self) {
        case .Apple:
            return &quot;Apple&quot;
        case .Orange:
            return &quot;Orange&quot;
        case .Banana:
            return &quot;Banana&quot;
        case .Peach:
            return &quot;Peach&quot;
        default:
            return String(self.toRaw())
    }
}
</code></pre></div>
<p>}</p>

<p>var value = Fruit.Orange
var valueWithType:Fruit  = .Peach
valueWithType.toRaw()
var outOfRange = Fruit.fromRaw(3.0) // 返回值为nil
outOfRange?.toString() // 返回值为nil
<code>
枚举除了有原始值之外，还可以有实例值。可以将枚举想象为一个容器，里面可以装一个或多个值，这些值是在创建实例时放进去的，不同的实例放的值不同。
不过，貌似使用了实例值就不能用原始值了，即不能再指定Double这种类型，不能附原始值，不能使用toRaw、fromRaw方法。
</code> python
enum Fruit {
    case Apple(String, String)
    case Orange(String), Banana(Int), Peach
}</p>

<p>let apple = Fruit.Apple(&quot;Price:32&rdquo;,&ldquo;Size:4&rdquo;)
switch(apple) {
    case let .Apple(price, size):
        println(&ldquo;Info: (price), (size)&rdquo;)
    case .Orange:
        println(&ldquo;orange&rdquo;)
    default:
        println(&ldquo;default&rdquo;)
}
&ldquo;`</p>

<h2 id="optional值">Optional值</h2>

<p>Swift中常量（let）定义时必须赋初始值，变量（var）可以不赋值，但需要显示指定类型，如<code>var value : Int</code>。
Swift不自动给变量赋初始值，变量使用前必须初始化。</p>

<p>如果使用时还无法确定初始值，那就需要用到Optional值了。Optional可以通过?来使用。
<code>python
// 声明Optional值变量
var shape:Shape? = nil
// 对Optional值操作时，需要做空值判断，判断是否能响应后面的操作。
// 如果shape为nil，则?之后的被忽略，返回nil；否则执行?后的代码
let value = shape?.num
</code>
函数的返回值也可以是Optional值，即可能返回nil
<code>python
func getSomeValue() -&gt; Int? {
    return nil
}
</code>
实际上，Optional是个enum，其中定义了None和Some两种类型。nil就等价于Optional.None。所以在使用Optional值时，如调用方法、属性、下标索引等，必须在Optional值后面加?来使用，不然会有语法错误。?是Optional定义的一种快捷的拆包方式。Optional的定义如下：
&rdquo;` python
enum Optional<T> : LogicValue, Reflectable { 
    case None 
    case Some(T) 
    init() 
    init(_ some: T) </p>
<div class="highlight"><pre><code class="text">/// Allow use in a Boolean context. 
func getLogicValue() -&gt; Bool 

/// Haskell&#39;s fmap, which was mis-named 
func map&lt;U&gt;(f: (T) -&gt; U) -&gt; U? 
func getMirror() -&gt; Mirror 
</code></pre></div>
<p>}
&ldquo;`
那除了后面加?之外，还有没有别的拆包方法呢？有的，有两种：</p>

<ol>
<li>Optional Binding
<code>python
var value : String?
if let tmp = value {
let hashStr = tmp.hashValue
}
</code></li>
<li>后面加!号，表示确定非nil，强制拆包。当然，如果是nil的话会crash
<code>python
var value : String?
value!.hashValue
</code>
哇！还有一个!号，对，!号还有一个用法，就是用来声明隐式拆包的Optional
（Implicitly Unwrapped Optionals），这样对变量操作时，会自动补上一个!进行拆包。当然，自己补上!?也是可以的。
<code>python
var value : String!
value.hashValue // 语法OK，但是会crash
value!.hashValue // 语法OK，但是会crash
value?.hashValue // 语法OK，不会crash
</code>
Optional是够复杂的，把整个Swift语法简洁漂亮的美好形象都打破了，有没有？好吧，我保证这绝对是本文里面语法最复杂的部分了，后面不再会超出你的想像了。来个测试试试看，下面这段代码会打印出啥？答案在<a href="#answer">最下方</a>
<code>python
let optval: Bool? = false
if optval               { println(&quot;1&quot;) }
if optval!              { println(&quot;2&quot;) }
if optval == true       { println(&quot;3&quot;) }
if optval! == true      { println(&quot;4&quot;) }
if optval == false      { println(&quot;5&quot;) }
if optval! == false     { println(&quot;6&quot;) }
</code></li>
</ol>

<h2 id="类">类</h2>

<p>类目前还没有public、private等权限控制，这个社区呼声最高，相信以后会有的。</p>

<p>类的示例代码如下，比较值得注意的是：
1. 重载父类方法要用override显示声明
2. 可以在通过willSet、didSet在修改变量值前后获得通知
3. 可以通过get、set给变量设置一个别名，并做一些运算。真心觉得这个应该配上访问权限来使用
&rdquo;` python
class Shape {
    init() { // 等价构造函数
        num = 1
        println(&ldquo;<Shape> init: (num)&rdquo;)
    }
    deinit { // 等价析构函数
        num = 0
        println(&ldquo;<Shape> deinit: (num)&rdquo;)
    }</p>
<div class="highlight"><pre><code class="text">var num = 0
func add(a:Int, b:Int) -&gt; Int {
    println(&quot;&lt;Shape&gt; add&quot;)
    return a + b;
}
</code></pre></div>
<p>}</p>

<p>class SonShape:Shape {
    init() {
        super.init()
        num = 2
        println(&ldquo;[Son] init: (num)&rdquo;)
    }
    init(value:Int) {
        super.init()
        num = value
        println(&ldquo;[Son] init with value: (num)&rdquo;)
    }
    deinit {
        num = -1
        println(&ldquo;[Son] deinit: (num)&rdquo;)
    }</p>
<div class="highlight"><pre><code class="text">func minus(a:Int, b:Int) -&gt; Int {
    println(&quot;[Son] minus: \(num)&quot;)
    return a - b;
}
// 重载父类中的函数
override func add(a:Int, b:Int) -&gt; Int {
    println(&quot;[Son] add&quot;)
    return super.add(a, b: b);
}
// willSet、ditSet只是值设置前的前后处理，preAfter和num一样是正常变量，所以可以附值
var preAfter:Int = 0 {
    willSet {
        println(&quot;will set \(newValue)&quot;)
    }
    didSet {
        println(&quot;did set&quot;)
    }
}
// get、set类似wrapper或别名，triple并不是实际存在的变量，所以不能附值
var triple:Double {
    get {
        return Double(num) * 3
    }
    set {
        num = Int(newValue / 3)
    }
}
</code></pre></div>
<p>}
// usage
var s = Shape();
s.num = s.add(3, b: 8)</p>

<p>var son = SonShape(value: 4)
son.add(7, b: 9)
son.triple
son.triple = 99
son.preAfter
son.preAfter = 10
&ldquo;`</p>

<h2 id="struct">struct</h2>

<p>struct和class的主要区别在于，
<strong>结构体是按值传递,类是按引用传递</strong>。</p>

<h2 id="接口和扩展">接口和扩展</h2>

<p>接口定义如下，
<code>python
protocol Speak {
    var des: String {get}
    mutating func say()
}
// usage
var man : Speak? = nil
</code>
其中，get用于控制访问权限，表明只能获取不能设置；mutating表示say函数可以修改内部内容，
class默认可以修改类，无需声明，struct需要通过mutating声明会修改结构体内容。</p>

<p>类、结构体、枚举都可以实现接口。</p>

<p>可以使用extension让任何现有的类型实现新的protocol，例如让Double类型实现Speak接口。
<code>python
extension Double:Speak {
    var des : String {
        return &quot;Double value&quot;
    }
    func say() {
        println(&quot;\(self.des): \(self)&quot;)
    }
}
// usage
3.2.say()
</code></p>

<h2 id="答案">答案</h2>

<p><a name="answer">答案</a>是会打印出 1 5 6 。可以copy到playground里试试看 ^_^</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift资源汇总]]></title>
    <link href="http://erikge.com/articles/SwiftResSummary"/>
    <updated>2014-06-20T15:54:19+08:00</updated>
    <id>http://erikge.com/articles/SwiftResSummary</id>
    <content type="html"><![CDATA[<p>最近iOS的开发世界里最热的应该就是Swift了。Swift让大家再次站在了同一起跑线上，而且是那么酷的脚本语言的语法。<br>
经过这不到一个月的时间，Swift的相关教程、资源、论坛蓬勃而出。就像美剧养肥了再看一样，汇总一些养肥的资源。</p>

<!--more-->

<h2 id="教程">教程</h2>

<ul>
<li><a href="http://vdisk.weibo.com/s/EhsPPzRRQ5CZ/1402621206">The Swift Programming Language中文完整版（CocoaChina精校</a></li>
<li><a href="http://numbbbbb.gitbooks.io/-the-swift-programming-language-/">github上的翻译项目，网友力量的再一次体现</a>，离线<a href="https://www.gitbook.io/download/pdf/book/numbbbbb/-the-swift-programming-language-?lang=">pdf版</a></li>
</ul>

<h2 id="热闹的论坛">热闹的论坛</h2>

<ul>
<li><a href="http://swiftist.org/">http://swiftist.org/</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开始iOS开发]]></title>
    <link href="http://erikge.com/articles/SetupEnvironment"/>
    <updated>2014-03-12T16:04:53+08:00</updated>
    <id>http://erikge.com/articles/SetupEnvironment</id>
    <content type="html"><![CDATA[<p>简要列出快速上手开发iOS程序需要做得事项，以便于在心中有一个整体估计。本文尽量作为一个避免细节的梗概。</p>

<!--more-->

<h2 id="开发环境">开发环境</h2>

<p>搭建开发环境，基本上就是安装各种工具软件。</p>

<ol>
<li>xcode安装

<ul>
<li>AppStore中下载安装xcode程序</li>
<li>安装command line tools。xcode5中不再提供下载，需要从<a href="https://developer.apple.com/downloads/index.action">Apple Developer Tools site</a>下载，或者通过命令行运行<code>xcode-select --install</code>下载安装</li>
<li>第一次在xcode运行程序时，enable developer mode，输入本机密码</li>
<li>在xcode中下载开发文档</li>
</ul></li>
<li>真机调试（如果加入苹果开发者计划，并且是Agent、Admin，如下自动化操作最省事）

<ul>
<li><code>Xcode-&gt;Preferences-&gt;Account</code>添加自己的账号，<code>View Details</code>刷新Provisioning Profiles</li>
<li>插入iphone设备，选择信任</li>
<li>运行程序，出现签名错误，选择自动Fix Issue；出现证书问题，选择自动Fix Issue</li>
<li>（可选）可以导出account备份，下次换机器就不用再重复上述第1、3步</li>
</ul></li>
<li>JDK安装</li>
<li>source tree安装，便于git做代码管理</li>
<li>Homebrew安装，便于安装各种命令行工具

<ul>
<li><code>ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)”</code></li>
<li>You should run <code>brew doctor</code> <em>before</em> you install anything.</li>
</ul></li>
<li>SlickEdit安装，非常好用的IDE，需要写c、cpp代码必备</li>
</ol>

<h2 id="处理器架构">处理器架构</h2>

<p>到目前为止，iOS设备采用的都是arm架构的处理器，使用arm指令集；模拟器运行在intel芯片的mac机上，采用的是x86架构，使用x86指令集，对应的编译选项是i386。armv6, armv7等实质上是arm指令集的不同版本，原则上是向下兼容的，例如支持armv7的cpu可以运行armv7选项编译出的程序，也可以运行armv6选项编译出的程序。</p>

<p>已有的iOS设备和arm指令集版本对应关系如下：</p>

<table><thead>
<tr>
<th>指令集版本</th>
<th>iOS设备</th>
</tr>
</thead><tbody>
<tr>
<td>armv6</td>
<td>iPhone，iPhone2，iPhone 3G，第一代、第二代iPod Touch</td>
</tr>
<tr>
<td>armv7</td>
<td>iPhone 3GS,iPhone 4,iPhone 4S，iPad，iPad 2，the new iPad，iPod Touch 3G，iPod Touch 4</td>
</tr>
<tr>
<td>armv7s</td>
<td>iPhone 5</td>
</tr>
<tr>
<td>arm64</td>
<td>iphone 5s，iPad mini 2，iPad Air</td>
</tr>
</tbody></table>

<p>xcode可以把不同指令集编译的版本都打包到同一程序中，这样在不同的设备上就可以自动选择最佳的指令集编译版本，缺点就是体积大点儿。可以根据想支持的iOS设备的多少设置工程Build Setting的Architectures中的<code>Build Active Architecture Only</code>和<code>Architectures</code>，<code>Valid Architectures</code>。</p>
]]></content>
  </entry>
  
</feed>
