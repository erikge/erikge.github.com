<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 时光 &#149 印记]]></title>
  <link href="http://erikge.com/categories/ios/atom.xml" rel="self"/>
  <link href="http://erikge.com/"/>
  <updated>2014-07-24T17:21:58+08:00</updated>
  <id>http://erikge.com/</id>
  <author>
    <name><![CDATA[erik ge]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift的问题]]></title>
    <link href="http://erikge.com/articles/SwiftTroubles"/>
    <updated>2014-06-27T23:37:20+08:00</updated>
    <id>http://erikge.com/articles/SwiftTroubles</id>
    <content type="html"><![CDATA[<p>一种技术的出现解决了一些问题，同时也会带来更多的问题。正因为Swift的高级特性，也由此带来了一些复杂性和一些潜在的问题。</p>

<!--more-->

<h2 id="内存管理">内存管理</h2>

<p>Swift 使用自动引用计数(ARC)来自动管理内存。大部分情况下无需考虑内存的分配和释放，但要注意某些可能会导致内存问题的使用方法。</p>

<h3 id="arc工作原理">ARC工作原理</h3>

<p>强引用(strong reference)：将一个类的实例赋值给一个属性或者常量或者变量，这个属性、常量或者变量就是这个实例的强引用。<br>
弱引用(weak reference)：弱引用不会增加实例的引用计数，因此不会阻止 ARC 销毁被引用的实例。弱引用只能声明为可选类型(optional type)的变量。<br>
无主引用(unowned reference)：无主引用也不强持有实例，但无主引用默认始终有值。无主引用只能定义为非可选类型(non-optional type)。</p>

<p>强引用还存在时，ARC不会释放这个实例。</p>

<h3 id="类实例间的强引用环">类实例间的强引用环</h3>

<p>两个实例相互引用对方作为自己的属性，彼此保持对方的强引用，这样就产生了强引用环，导致这两个实例永远不被释放。
&ldquo;` python
class Person {
    var apartment: Apartment?</p>
<div class="highlight"><pre><code class="text">deinit {
    println(&quot;~~deinit Person&quot;)
}
</code></pre></div>
<p>}
class Apartment {
    var tenant: Person?</p>
<div class="highlight"><pre><code class="text">deinit {
    println(&quot;~~deinit Apartment&quot;)
}
</code></pre></div>
<p>}</p>

<p>// 产生强引用环的情况
var foo: Person? = Person()
var house: Apartment? = Apartment()
if let tmp = foo {
    tmp.apartment = house
}
house!.tenant = foo
// 即便都置为nil也无法释放资源
foo = nil
house = nil
<code>
通过弱引用或无主引用来解决这个问题。如果生命周期中，引用（上例中的属性）有时有值，有时为nil，使用弱引用；如果始终有值，使用无主引用。
</code> python
// 通过弱引用解决
class Apartment {
    weak var tenant: Person?</p>
<div class="highlight"><pre><code class="text">deinit {
    println(&quot;~~deinit Apartment&quot;)
}
</code></pre></div>
<p>}
&rdquo;`</p>
<div class="highlight"><pre><code class="python"><span class="o">//</span> <span class="err">通过无主引用解决，如果</span><span class="n">house</span><span class="err">必须有主人的话</span>
<span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">apartment</span><span class="p">:</span> <span class="n">Apartment</span><span class="err">?</span>

    <span class="n">deinit</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;~~deinit Person&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Apartment</span> <span class="p">{</span>
    <span class="n">unowned</span> <span class="n">var</span> <span class="n">tenant</span><span class="p">:</span> <span class="n">Person</span>

    <span class="n">init</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tenant</span> <span class="o">=</span> <span class="n">person</span>
    <span class="p">}</span>

    <span class="n">deinit</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;~~deinit Apartment&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">var</span> <span class="n">foo</span><span class="p">:</span> <span class="n">Person</span><span class="err">?</span> <span class="o">=</span> <span class="n">Person</span><span class="p">()</span>
<span class="n">var</span> <span class="n">house</span><span class="p">:</span> <span class="n">Apartment</span><span class="err">?</span> <span class="o">=</span> <span class="n">Apartment</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="n">foo</span><span class="err">!</span><span class="p">)</span>
<span class="o">//</span> <span class="err">相互引用</span>
<span class="k">if</span> <span class="n">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="n">tmp</span><span class="o">.</span><span class="n">apartment</span> <span class="o">=</span> <span class="n">house</span>
<span class="p">}</span>
<span class="n">house</span><span class="err">!</span><span class="o">.</span><span class="n">tenant</span> <span class="o">=</span> <span class="n">foo</span><span class="err">!</span>
<span class="o">//</span> <span class="err">可以正常释放资源</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">nil</span>
<span class="n">house</span> <span class="o">=</span> <span class="n">nil</span>
</code></pre></div>
<p>如果无主引用的例子中，Person也一直有Apartment的话，Person中的apartment属性可以使用隐式展开的可选属性。</p>

<h3 id="闭包产生的强引用环">闭包产生的强引用环</h3>

<p>将一个闭包赋值给类实例的某个属性，并且这个闭包使用了实例（访问了实例的某个属性，或调用了实例的某个方法。
&ldquo;` python
class HTMLElement {
    let name: String
    let text: String?</p>
<div class="highlight"><pre><code class="text">// @lazy保证初始化完成以及 self 确实存在后,才能访问 lazy 属性
@lazy var asHTML: () -&gt; String = {
    if let text = self.text {
        return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
    } else {
        return &quot;&lt;\(self.name) /&gt;&quot;
    }
}

init(name: String, text: String? = nil) {
    self.name = name
    self.text = text
}

deinit {
    println(&quot;~~\(name) deinit&quot;)
}
</code></pre></div>
<p>}</p>

<p>var html: HTMLElement? = HTMLElement(name: &quot;head&rdquo;)
html?.asHTML() // 使用闭包后产生了强引用环
html = nil // HTMLElement实例和它的闭包都不会被销毁
&ldquo;`</p>

<p>可以通过闭包占用列表(closuer capture list)解决这个问题。Swift有如下约束：只要在闭包内使用 self 的成员,就要用 self.someProperty 或者
self.someMethod（而非只是 someProperty 或 someMethod）。这可以提醒你可能会不小心就占有了 self，导致强引用环。<br>
占有列表放置在闭包参数列表和返回类型之前。
<code>python
@lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self] (index: Int, stringToProcess: String) -&gt; String in
    // closure body goes here
}
@lazy var someClosure: () -&gt; String = {
    [weak self] in
    // closure body goes here
    self?.someProperty
}
</code></p>

<h2 id="构造器">构造器</h2>

<p>构造器的部分也挺复杂的，类有一套构造器的规矩，扩展还可以添加新的构造器。其中有哪些问题需要注意？后续补充。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的语法细节]]></title>
    <link href="http://erikge.com/articles/SwiftSyntax"/>
    <updated>2014-06-26T14:09:50+08:00</updated>
    <id>http://erikge.com/articles/SwiftSyntax</id>
    <content type="html"><![CDATA[<p>Swift类似脚本语言的高级语法特性，让Swift语言使用起来很直观，很符合人的直觉，整体感觉很简洁很舒服。使用不同编程语言的程序员都能找到熟悉的感觉，这种亲切感必将吸引更多的开发者。<br>
本文总结Swift中需要注意的语法细节，完整的语法说明参考苹果的官方文档<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/">The Swift Programming Language</a>。</p>

<!--more-->

<h2 id="变量名和常量名">变量名和常量名</h2>

<p>变量名、常量名可以使用Unicode字符，但不能包含连线符、制表符、数学符号、箭头和一些保留字符。
如果非要使用保留字符（如关键字）作为变量名，通过反引号（`）将字符包围（如`class`）。</p>

<h2 id="注释">注释</h2>

<p>注释可以嵌套，这样注释大段代码就方便了，只管开头结尾就好，不用担心里面的注释结束符捣乱了。</p>
<div class="highlight"><pre><code class="python"><span class="o">/*</span> <span class="err">这是第一个多行注释的开头</span>
<span class="n">code</span> <span class="n">here</span>
<span class="o">/*</span> <span class="err">这是第二个被嵌套的多行注释</span> <span class="o">*/</span>
<span class="n">more</span> <span class="n">code</span> <span class="n">here</span>
<span class="err">这是第一个多行注释的结尾</span> <span class="o">*/</span>
</code></pre></div>
<h2 id="数学相关的操作">数学相关的操作</h2>

<h3 id="数值字面量">数值字面量</h3>

<p>整数字面量可以是十进制、二进制、八进制、十六进制
<code>python
let decimalInteger = 17
let binaryInteger = 0b10001     // 二进制的 17
let octalInteger = 0o21         // 八进制的17
let hexadecimalInteger = 0x11   // 十六进制的 17
</code></p>

<p>浮点字面量可以是十进制、十六进制。小数点两边必须有至少一个数字。有可选的指数，十进制为e、十六进制为p。
<code>python
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1  // 十进制指数的12.1875
let hexadecimalDouble = 0xC.3p0 // 十六进制指数的12.1875
</code></p>

<p>可以添加下划线提高可读性，不影响字面量的值。
<code>python
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></p>

<p>可以通过typealias给类型起个更喜欢的别名，如<code>typealias AudioSample = UInt16</code>，这时AudioSample等价于UInt16。</p>

<h3 id="运算符">运算符</h3>

<p>求余运算符。<br>
% 为 求余运算符 或 取模运算符，可以对负数和浮点数操作。被求余数的符号被忽略。
<code>python
9 % 4 // 等于1
9 % -4 // 和 9 % 4 等价，等于1
-8 % 2.5 // 等于-0.5
</code></p>

<p>区间运算符。<br>
<code>a...b</code>表示从a到b(包括 a 和 b)的所有值的闭区间；<code>a..b</code>表示包括a不包括b的前闭后开区间。</p>

<p>溢出运算符。<br>
Swift的数值计算默认是不可溢出的，溢出行为会被捕获并报error。Swift提供了一套以&amp;开头的溢出运算符，包括<code>&amp;+</code>, <code>&amp;-</code>, <code>&amp;*</code>, <code>&amp;/</code>, <code>&amp;%</code>。
<code>python
var byte_min = Int8.max &amp;+ 1 // -128
var byte_max = Int8.min &amp;- 1 // 127
</code></p>

<p>位运算符。<br>
<code>python
let invert: UInt8 = ~0b11       // 按位取反
let and: UInt8 = 0xF &amp; 0xF0     // 按位与
let or: UInt8 = 0xF | 0xF0      // 按位或
let diff: UInt8 = 0xF ^ 0xF0    // 按位异或
let left: UInt8 = 0xFF &lt;&lt; 1     // 按位左移
let right: UInt8 = 1 &gt;&gt; 1       // 按位右移
</code></p>

<p>运算符函数。<br>
让已有的运算符也可以对自定义的类和结构进行运算，这称为运算符重载。<br>
@infix表示中置运算符，如a + b；<br>
@prefix表示前置运算符，如-a；<br>
@postfix表示后置运算符，如i++；<br>
@assignment表示组合赋值运算符，还需要把左参数设置成 inout，如a += 3；
<code>python
struct Point {
    var x = 0.0, y = 0.0
}
@infix func + (left: Point, right: Point) -&gt; Point {
    return Point(x: left.x + right.x, y: left.y + right.y)
}
@prefix func - (p: Point) -&gt; Point {
    return Point(x: -p.x, y: -p.y)
}
@assignment func += (inout l: Point, r: Point) {
    l = l + r
}
@prefix @assignment func ++ (inout p: Point) -&gt; Point {
    p += Point(x: 1.0, y: 1.0)
    return p
}
@postfix func ++ (inout p: Point) -&gt; Point {
    var ret = p
    ++p
    return ret
}
</code></p>

<p>自定义运算符。<br>
自定义的运算符只能从<code>/ = - + * % &lt; &gt; ! &amp; | ^ ~</code>中选择。
&ldquo;` python
operator prefix &lt;+&gt; {} // 先声明为运算符
@prefix @assignment func &lt;+&gt; (inout p: Point) -&gt; Point {
    p += p
    return p
}
var p = Point(x: 3, y: 4)
&lt;+&gt;p</p>

<p>// 自定义中置运算符可以定义优先级（默认为100）和结合性（默认为none）
operator infix +- { associativity left precedence 140 }
&rdquo;`
更完整的运算符的优先级和结合性参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-XID_655">官方文档</a></p>

<h2 id="字符和字符串">字符和字符串</h2>

<p>字符串字面量可以包含一下特殊字符：</p>

<ol>
<li>转义特殊字符 <code>\0 (空字符)、\\(反斜线)、\t (水平制表符)、\n (换行符)、\r (回车符)、\&quot; (双引号)、\&#39; (单引号)</code>。</li>
<li>单字节 Unicode 标量，写成<code>\xnn</code>,其中 nn 为两位十六进制数。</li>
<li>双字节 Unicode 标量，写成<code>\unnnn</code>,其中 nnnn 为四位十六进制数。</li>
<li>四字节 Unicode 标量，写成<code>\Unnnnnnnn</code>,其中 nnnnnnnn 为八位十六进制数。</li>
</ol>

<p>空字符串定义，二者等价
<code>python
var empty1 = &quot;&quot;
var empty2 = String()
</code></p>

<p>字符串可以通过“＋”拼接，两个Character可以相加得到String。
字符串String可以作为字符Character的集合，可以对其用for-in操作，如 <code>for character in &quot;Dog!???&quot;</code>。</p>

<p>计算字符串中字符的数量，通过全局countElements函数实现。<br>
计算字符串的字节数，可以考虑 utf16count * 2 得到。</p>

<p>字符串比较。可以通过<code>==</code>判断两个字符串包含的字符是否完全相同，通过hasPrefix/hasSuffix判断前缀/后缀是否相等。</p>

<p>可以通过uppercaseString/lowercaseString获得大写/小写版本。<br>
可以通过utf8获得UTF-8单元集合。<br>
可以通过utf16获得UTF-16单元集合。<br>
可以通过unicodeScalars获得21位的标量值集合。</p>

<h2 id="集合类型">集合类型</h2>

<p>Swift提供了数组和字典两种集合类型。</p>

<h3 id="数组">数组</h3>

<p>数组是类型安全的，要求有明确的类型，其中包含的元素的类型必须统一。</p>

<p>数组的定义
<code>python
var arrSimple: String[] = [&quot;one&quot;, &quot;two&quot;]
var arrComp: Array&lt;String&gt; = [&quot;one&quot;, &quot;two&quot;]
var arr = [&quot;one&quot;, &quot;two&quot;] // 依赖类型推断
// 定义空数组
var emptySimple: String[] = String[] ()
var emptyComp: Array&lt;String&gt; = Array&lt;String&gt;()
var emptyNotOK = [] // 未说明类型，后续无法使用
emptySimple = [] // 类型已知的情况下，可以用于变为空数组
// 用重复的值初始化数组
var threeDoubles = Double[](count: 3, repeatedValue:0.0)
var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5) // 不指定类型，依赖类型推断
// copy创建
var arr_new = Array(arr_old)
</code></p>

<p>数组的使用
<code>python 
var arr = String[]()
arr.count // 内部元素数量
arr.isEmpty
// 最后添加元素
arr.append(&quot;newValue&quot;)
arr += [&quot;newValue1&quot;, &quot;newValue2&quot;]
// 将数组中的一段替换为新值，被替换的部分的长度和新值的长度可以不一致
arr[1...2] = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]
// 添加、删除
arr.insert(&quot;insertValue&quot;, atIndex: 0)
arr.removeAtIndex(0)
arr.removeLast()
// 带数组的索引遍历
for (index, value) in enumerate(shoppingList) {
println(&quot;Item \(index + 1): \(value)&quot;)
// 数组可以相加来合并
var arr = arr1 + arr2
}
</code></p>

<p>当数组分配给常量时，数组的长度不能改变，但其中的值还可以改变。</p>

<h3 id="字典">字典</h3>

<p>Swift 的字典使用 Dictionary<KeyType, ValueType>定义,其中KeyType要求是可哈希的。</p>

<p>字典的定义
<code>python
var airports: Dictionary&lt;String, String&gt; = [&quot;TYO&quot;: &quot;Tokyo&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
var airports = [&quot;TYO&quot;: &quot;Tokyo&quot;, &quot;DUB&quot;: &quot;Dublin&quot;] // 依赖类型推断
</code></p>

<p>字典的使用
<code>python
// 添加
airports[&quot;LHR&quot;] = &quot;London&quot;
// 更新
airports[&quot;LHR&quot;] = &quot;London Heathrow&quot;
airports.updateValue(&quot;London Heathrow&quot;, forKey:&quot;LHR&quot;)
// 遍历
for (airportCode, airportName) in airports {
    println(&quot;\(airportCode): \(airportName)&quot;)
}
</code></p>

<p>当字典分配给常量时，大小和其中的键值对都不能更改。</p>

<h2 id="值类型和引用类型">值类型和引用类型</h2>

<p>Swift中的类型可以分为值类型和引用类型。<br>
值类型赋值给变量、常量，或传递给函数参数，或函数返回值时，得到的是新创建的一份拷贝。这样两个变量的后续操作相互独立，不相互影响。<br>
引用类型在代码中传递时，得到的是同一个实例。两个变量的后续操作实际是对同一实例的操作。<br>
引用类似C中的指针、Java中的类对象引用。Swift中也是没有指针、地址等概念的。</p>

<p><strong>值类型：</strong></p>

<ul>
<li>所有的基本类型。整数(Integer)、浮点数(floating-point)、布尔值(Booleans)、字符串(string)、数组(array)和字典(dictionaries)。并且都是以结构体的形式在后台实现。</li>
<li>结构体、枚举。其中包含的任何值类型，在代码中传递时都会被复制。</li>
</ul>

<p><strong>引用类型：</strong></p>

<ul>
<li>类</li>
<li>闭包。闭包包括函数。</li>
</ul>

<p>恒等运算符（恒等<code>===</code>、不恒等<code>!==</code>），判断两个变量、常量是否引用同一个实例的方法。</p>

<p>在实际开发中，并没有必要因为值拷贝的原因减少赋值等传递。因为在实际编译时，编译器会保证复制只发生在绝对必要的情况下以提高性能</p>

<p>集合类型的传递和拷贝行为略有些复杂。集合类型在传递时，先不做拷贝，只有当值发生变化时才执行拷贝。字典在其中的键－值对改变或size改变时，都认为是发生变化，触发拷贝；但数组在修改其中元素时不认为是发生变化，只有在长度改变时才认为是发生变化，才触发拷贝。
数组长度改变的情况包括附加(appending)，插入(inserting)，删除(removing)或者使用范围下标(ranged subscript)去替换这一范围内的元素。</p>

<p>集合类型在拷贝时执行的都是浅拷贝。当其中的元素时引用类型时，拷贝的是引用。
<code>python
var a = [1, 2, 3], b = a
a[0] = 10
a == b              // true，没copy，a修改不认为是变化
a === b             // false，值类型，返回false符合语法
a[1...2] = [5, 6]
a == b              // false，发生copy，a变化了
</code>
触发copy的方法
<code>python
var a = [1, 2, 3], b = a
a[0] = 10
b.unshare()     // 触发b的copy
a[1] = 11       // a[10,11,3], b[10,2,3]
// or
var a = [1, 2, 3]
var b = a.copy()
a[0] = 10
a[1] = 11       // a[10,11,3], b[1,2,3]
</code></p>

<h2 id="函数">函数</h2>

<p>多返回值。<br>
函数可以返回多个值，以元组的形式实现。
<code>python
func getPoint() -&gt; (x: Int, y: Int) {
    var a = 8, b = 7
    return (a, b)
}
var ret = getPoint()
ret.x
ret.y
func getInfo() -&gt; (Int, String) {
    return (9, &quot;Not Found&quot;)
}
var info = getInfo()
info.0
info.1
</code></p>

<p>外部形参名。<br>
函数形参名分为本地形参名和外部形参名。本地形参名只在函数内部有效，外部形参名用于外部调用时声明。
<code>python
func join(string s1: String, toString s2: String, withJoiner joiner: String) -&gt; String {
    return s1 + joiner + s2
}
// usage
join(string: &quot;Hello&quot;, toString: &quot;world&quot;, withJoiner: &quot;, &quot;)
</code>
外部形参和本地形参同名。
<code>python
func join(#string: String, #toString: String, #withJoiner: String) -&gt; String {
    return string + withJoiner + toString
}
join(string: &quot;Hello&quot;, toString: &quot;world&quot;, withJoiner: &quot;, &quot;)
</code></p>

<p>默认值。<br>
函数形参可以带有默认值，虽然默认值形参可以在任何位置，但是建议放在形参列表的末尾。<br>
Swift为带默认值的形参自动提供了外部形参名，可以通过&quot;_&ldquo;来关闭这种行为
&rdquo;` python
func join(s1: String, s2: String = &ldquo;world&rdquo;, jo: String) -&gt; String {
    return s1 + jo + s2
}
join(&ldquo;Hello&rdquo;, &ldquo;, &rdquo;) // 输出 &ldquo;Hello, world&rdquo;
join(&ldquo;Hello&rdquo;, s2: &ldquo;Amy&rdquo;, &ldquo;, &rdquo;) // 不使用默认值</p>

<p>func join2(s1: String, _ s2: String = &ldquo;world&rdquo;, jo: String) -&gt; String {
    return s1 + jo + s2
}
join2(&ldquo;Hello&rdquo;, &ldquo;Foo&rdquo;, &ldquo;, &rdquo;)
&ldquo;`</p>

<p>可变形参。<br>
传递至可变形参的值在函数主体内是以适当类型的数组存在的。
<code>python
func arithmeticMean(numbers: Double...) -&gt; Double {
    for number in numbers {
        // todo
    }
}
</code></p>

<p>变量形参。<br>
函数的形参默认是常量。试图在函数体内改变函数形参的值会引发一个编译时错误。
可以通过使用变量形参，在函数内得到一个有形参值的变量副本。
<code>python 
func add(var a: Int, b: Int) -&gt; Int{
    a = a + b
    return a
}
</code></p>

<p>In-Out形参。<br>
只能传递一个变量作为 in-out 形参对应的实参，变量前加&amp;号。
不能传递一个常量或者字面量作为实参,因为常量和字面量不能被修改。
<code>python
func swap(inout a:Int, inout b:Int) {
    let temp = a
    a = b
    b = temp
}
// usage
var x = 5, y = 9
swap(&amp;x, &amp;y)
x // 9
y // 5
</code></p>

<p>嵌套函数。<br>
除了在全局作用域中定义的全局函数外，还可以在函数体内部定义嵌套函数。
&rdquo;` python
func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
    func stepForward(input: Int) -&gt; Int { return input + 1 }
    func stepBackward(input: Int) -&gt; Int { return input - 1 }</p>
<div class="highlight"><pre><code class="text">return backwards ? stepBackward : stepForward
</code></pre></div>
<p>}
&ldquo;`</p>

<h2 id="类和结构体">类和结构体</h2>

<p>类和结构体有很多共同点：</p>

<ul>
<li>定义属性用于储存值</li>
<li>定义方法用于提供功能</li>
<li>定义下标用于通过下标语法访问值</li>
<li>定义初始化器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>符合协议以对某类提供标准功能</li>
</ul>

<p>与结构体相比,类还有如下的附加功能：</p>

<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>取消初始化器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用</li>
</ul>

<p>定义：
<code>python
class SomeClass {
    // class definition goes here
}
struct SomeStructure {
    // structure definition goes here
}
</code></p>

<h3 id="属性">属性</h3>

<p>属性部分包含：</p>

<ol>
<li>存储属性。存储常量、变量，可用于类和结构体</li>
<li>计算属性。计算值，可用于类、结构体和枚举</li>
<li>属性监视器。监控属性值的变化</li>
</ol>

<p>存储属性。<br>
@lazy标示的为延迟存储属性，创建时为nil，在第一次被调用时才初始化。
<code>python
class Lazy {
    let left: Int = 5
    @lazy var top: Int = 3
}
</code></p>

<p>计算属性。<br>
计算属性不直接存储值，提供一个get来获取值，一个可选的set来设置值。只实现get，不实现set时，为只读属性。计算属性只能通过var来定义。
&rdquo;` python
struct Range {
    var normal: String {
        get {
            return &ldquo;Getter&rdquo;
        }
        set (new_str) {
            println(new_str)
        }
    }
    var quick: Double {
        get {
            return 1.0
        }
        set { // 默认参数名为 newValue
            println(newValue)
        }
    }
    var quickReadOnly: Int {
        return 1 + 1
    }</p>

<p>}
var ran = Range()
ran.normal
ran.normal = &ldquo;aabbcc&rdquo;
ran.quickReadOnly
&ldquo;`</p>

<p>属性监视器。<br>
可以为除了延迟存储属性之外的其他存储属性添加属性监视器，也可以通过重载属性的方式为继承的属性(包括存储属性和计算属性)添加属性监视器。<br>
willSet 在设置新的值之前调用，将新的值作为参数传入，默认名称为newValue。didSet 在新的值被设置之后立即调用，将旧的属性值作为参数传入，默认名称为oldValue。<br>
willSet 和 didSet 监视器在属性初始化过程中不会被调用，他们只会当属性的值在初始化之外的地方被设置时被调用。</p>

<p>计算属性和存储型属性监视器所描述的模式也可以用于全局变量和局部变量，即可定义计算型变量和为存储型变量定义监视器。</p>

<p>类型属性。<br>
上述的属性在实例之间相互独立，属于实例属性。也可以为类型定义类型属性，不管有多少实例，这些属性都只有一份。<br>
对于值类型(指结构体和枚举)可以定义存储型和计算型类型属性，对于类(class)则只能 定义计算型类型属性。
&rdquo;` python
struct SomeStruct {
    static let property = &ldquo;structure&rdquo;
    static var type: Int {
        return 0
    }
}
enum SomeEnum {
    static let property = &ldquo;enumeration&rdquo;
    static var type: Int {
        return 1
    }
}
class SomeClass {
    class var type: Int {
        return 2
    }</p>

<p>}
// usage
SomeStruct.type
&ldquo;`</p>

<h3 id="方法">方法</h3>

<p>类、结构体、枚举都可以定义实例方法或类型方法。方法自动为第二个参数和后续所有参数提供同名外部参数名称，可以自己指定外部参数名，或通过&rdquo;_&ldquo;关闭默认行为。</p>
<div class="highlight"><pre><code class="python"><span class="k">class</span> <span class="nc">Counter</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">func</span> <span class="n">increase</span><span class="p">(</span><span class="n">amout</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">times</span> <span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="p">{</span>
        <span class="n">value</span> <span class="o">+=</span> <span class="n">amout</span> <span class="o">*</span> <span class="n">times</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="p">}</span>
    <span class="n">func</span> <span class="n">increase</span><span class="p">(</span><span class="n">amout</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">numberOfTimes</span> <span class="n">times</span> <span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="p">{</span>
        <span class="n">value</span> <span class="o">+=</span> <span class="n">amout</span> <span class="o">*</span> <span class="n">times</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="p">}</span>
    <span class="n">func</span> <span class="n">increase</span><span class="p">(</span><span class="n">amout</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">_</span> <span class="n">times</span> <span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="p">{</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="n">amout</span> <span class="o">*</span> <span class="n">times</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="o">//</span> <span class="n">usage</span>
<span class="n">var</span> <span class="n">ins</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="n">ins</span><span class="o">.</span><span class="n">increase</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">ins</span><span class="o">.</span><span class="n">increase</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">numberOfTimes</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ins</span><span class="o">.</span><span class="n">increase</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div>
<p>另外一个值得注意的问题是，结构体和枚举是值类型。一般情况下，值类型的属性不能在它的实例方法中被修改。如果方法需要修改结构体内容，需要用mutating显式声明。
&rdquo;` python
enum TriState {
    case Off, Low, High</p>
<div class="highlight"><pre><code class="text">mutating func next() {
    switch self {
        case .Off:
            self = .Low
        case Low:
            self = High
        case High:
            self = Off
    }
}
</code></pre></div>
<p>}
var light = TriState.High
light.next()
light == .Off // true
&ldquo;`</p>

<p>类型方法，被类型本身调用的方法。<br>
声明类的类型方法，在方法的 func 关键字之前加上关键字 class；声明结构体和枚举的类型方法，在方法的 func 关键字之前加上关键字 static。</p>

<h3 id="结构体">结构体</h3>

<p>结构体有一个自动生成的成员逐一初始化器，用于初始化新结构体实例中的所有成员属性。
<code>python
struct Resolution {
    var width = 0
    var heigth = 0
}
let vga = Resolution(width:640, heigth: 480)
</code></p>

<h3 id="附属脚本">附属脚本</h3>

<p>附属脚本附属脚本可以定义在类(Class)、结构体(structure)和枚举(enumeration)这些目标中，允许你通过在实例后面的方括号中传入一个或者多个的索引值来对实例进行访问和赋值，类似于数组、字典的使用方法。
&rdquo;` python
subscript(index: Int) -&gt; Int {
    get {
        // 返回与入参匹配的Int类型的值
    }</p>
<div class="highlight"><pre><code class="text">set(newValue) {
    // 执行赋值操作
}
</code></pre></div>
<p>}
&ldquo;`</p>

<h3 id="类">类</h3>

<h4 id="继承">继承</h4>

<p>子类可以调用、访问、重写（override）超类的方法（实例方法和类方法），属性（实例属性和类属性）和附属脚本。</p>
<div class="highlight"><pre><code class="python"><span class="k">class</span> <span class="nc">Vehicle</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">wheels</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">var</span> <span class="n">passengers</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">wheels</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">passengers</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="n">deinit</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">func</span> <span class="n">description</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;This is a Vehicle&quot;</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">var</span> <span class="n">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
        <span class="n">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;Vehicle&quot;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Bicycle</span> <span class="p">:</span> <span class="n">Vehicle</span> <span class="p">{</span>
    <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">super</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
        <span class="n">wheels</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">}</span>

    <span class="n">override</span> <span class="n">func</span> <span class="n">description</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;This is a Bicycle&quot;</span>
    <span class="p">}</span>

    <span class="n">override</span> <span class="n">var</span> <span class="n">passengers</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="n">get</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">super</span><span class="o">.</span><span class="n">passengers</span>
    <span class="p">}</span>
    <span class="nb">set</span> <span class="p">{</span>
        <span class="nb">super</span><span class="o">.</span><span class="n">passengers</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">newValue</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">override</span> <span class="k">class</span> <span class="nc">var</span> <span class="n">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
    <span class="n">get</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;Bicycle&quot;</span>
    <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">Vehicle</span><span class="o">.</span><span class="n">name</span>
<span class="n">Bicycle</span><span class="o">.</span><span class="n">name</span>
<span class="n">var</span> <span class="n">bi</span> <span class="o">=</span> <span class="n">Bicycle</span><span class="p">()</span>
<span class="n">bi</span><span class="o">.</span><span class="n">passengers</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div>
<p>初始化器默认是不继承的，所以子类中调用super.init()保证使用父类的属性前已经初始化完成。<br>
通过super来访问父类。<br>
通过override显式声明重载。<br></p>

<p>@final可以防止override。
<code>@final var</code>，<code>@final func</code>，<code>@final class func</code>，以及<code>@final subscript</code>不能被重写。
<code>@final class</code>的类不可被继承。</p>

<h4 id="属性观察器（property-observer）-willset/didset">属性观察器（property observer） willSet/didSet</h4>

<p>可以为继承来的存储型或计算型属性、自己创建的存储型属性添加属性观察器；
不可以为常量存储型属性、只读计算型属性添加属性观察器，因为不会用到；
不可以同时提供set和属性观察器，因为set中就可以得到属性的变化。</p>

<h2 id="类型转换">类型转换</h2>

<p>类型转换在Swift中使用 is 和 as 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型和转换它的类型。
&rdquo;` python
class Media {
    var name: String
    init(name: String) {
        self.name = name
    }
}
class Movie: Media {}
class Song: Media {}</p>

<p>let library = [
    Movie(name: &ldquo;Matrix&rdquo;),
    Song(name: &ldquo;only&rdquo;),
    Movie(name: &ldquo;Hi&rdquo;),
]
// 类型检查：is
var isMovie = false
if library[0] is Movie {
    isMovie = true
}
&ldquo;`</p>

<p>类型转换as有两种不同的形式。可选形式as?返回一个Optional值；强制形式as转型后强制解包。
&rdquo;` python
var unknownType = library[1]
if let movie = unknownType as? Movie {
    movie.name
}</p>

<p>if unknownType is Movie {
    let movie = unknownType as Movie
} else if unknownType is Song{
    let song = unknownType as Song
}
&ldquo;`</p>

<p>Swift为不确定类型提供了两种特殊类型别名:</p>

<ol>
<li>AnyObject 可以代表任何 class 类型的实例。</li>
<li>Any 可以表示任何类型，除了方法类型(function types)。</li>
</ol>
<div class="highlight"><pre><code class="python"><span class="n">var</span> <span class="n">things</span> <span class="o">=</span> <span class="n">Any</span><span class="p">[]()</span>
<span class="n">things</span> <span class="o">+=</span> <span class="mi">0</span>
<span class="n">things</span> <span class="o">+=</span> <span class="mf">0.0</span>
<span class="n">things</span> <span class="o">+=</span> <span class="mi">42</span>
<span class="n">things</span> <span class="o">+=</span> <span class="mf">3.14159</span>
<span class="n">things</span> <span class="o">+=</span> <span class="s">&quot;hello&quot;</span>
<span class="n">things</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">thing</span> <span class="ow">in</span> <span class="n">things</span> <span class="p">{</span>
    <span class="n">switch</span> <span class="n">thing</span> <span class="p">{</span>
    <span class="n">case</span> <span class="mi">0</span> <span class="k">as</span> <span class="n">Int</span><span class="p">:</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;0 as an Int&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="mi">0</span> <span class="k">as</span> <span class="n">Double</span><span class="p">:</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;0 as a Double&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">let</span> <span class="n">someInt</span> <span class="k">as</span> <span class="n">Int</span><span class="p">:</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Int: \(someInt)&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">let</span> <span class="n">someDouble</span> <span class="k">as</span> <span class="n">Double</span> <span class="n">where</span> <span class="n">someDouble</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Positive double: \(someDouble)&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="ow">is</span> <span class="n">Double</span><span class="p">:</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;other Double&quot;</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">Double</span><span class="p">,</span> <span class="n">Double</span><span class="p">):</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Point: \(x), \(y)&quot;</span><span class="p">)</span>
    <span class="n">default</span><span class="p">:</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;something else&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="编程小技巧">编程小技巧</h2>

<ol>
<li>断言带可选的说明信息<code>assert(age &gt;= 0, &quot;A person&#39;s age cannot be less than zero&quot;)</code></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法糖]]></title>
    <link href="http://erikge.com/articles/SwiftCandy"/>
    <updated>2014-06-20T17:34:28+08:00</updated>
    <id>http://erikge.com/articles/SwiftCandy</id>
    <content type="html"><![CDATA[<p>Swift中引入了很多高级语言的特性，如闭包、命名空间、泛型、强类型（同时拒绝阴式类型转换）、多个返回值（元组）等等，这些高级的语法糖用好了可以极大提升工作效率，用不好也是语法坑。<br>
我们先体验一下Swift的糖衣炮弹。</p>

<!--more-->

<h2 id="闭包">闭包</h2>

<p>闭包是功能性自包含模块，可以在代码中被传递和使用。<br>
闭包可以 <strong>捕获</strong> 和存储其所在上下文中任意常量和变量的引用，这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift会管理在捕获过程中涉及到的内存操作。</p>

<p>全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之 一：</p>

<ol>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的没有名字的闭包</li>
</ol>

<p>闭包表达式比较像其他一些编程语言中的lambdas，拥有一些简洁的语法风格：</p>

<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>单表达式(single-expression)闭包可以省略 return 关键字</li>
<li>参数名称简写</li>
<li>Trailing 闭包语法</li>
</ul>

<p>闭包表达式语法：
<code>python
{ (parameters) -&gt; returnType in
    statements
}
</code>
闭包表达式语法可以使用常量、变量和 inout 类型作为参数，但不提供默认值。也可以在参数列表的最后使用可变参数。元组也可以作为参数和返回值。<br>
举个栗子。
<code>python
reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code>
因为排序闭包时作为函数参数进行传入的，函数参数的类型是确定的，即(String, String) -&gt; Bool的闭包。所以，闭包的类型可以被自动推断。
<code>python
reversed = sort(names, { s1, s2 in
    return s1 &gt; s2
} )
// 可以写在同一行，更加简洁
reversed = sort(names, { s1, s2 in return s1 &gt; s2 } )
</code>
单表达式闭包可以省略 return 关键字
<code>python
reversed = sort(names, { s1, s2 in s1 &gt; s2 } )
</code>
参数名简写，可以通过$0,$1,$2等位置引用参数，从0开始
<code>python
reversed = sort(names, { $0 &gt; $1 } )
</code>
运算符函数，大于号（&gt;）函数的类型正好和sort参数的类型一致，所以可以直接传入&gt;
<code>python
reversed = sort(names, &gt;)
</code>
Trailing 闭包 的写法。当函数只需要闭包一个参数时，甚至可以省略括号
<code>python
reversed = sort(names) { $0 &gt; $1 }
</code></p>

<p>捕获的常量和变量在超出原作用域之后仍然可以使用。而且不同的闭包捕获后存储的变量和常量是相互独立的。
<code>python
func makeIncrease(increaseStep: Int) -&gt; () -&gt; Int {
    var total = 0
    func increase() -&gt; Int {
        total += increaseStep
        return total
    }
    return increase
}
// usage
let increaseTen = makeIncrease(10)
increaseTen()   // 10
increaseTen()   // 20
let increaseSeven = makeIncrease(7)
increaseSeven() // 7
increaseTen()   // 30
</code></p>

<h2 id="元组">元组</h2>

<p>把多个值用()组合在一起就成了元组，元组内的值可以是任意类型，并且不要求是相同类型。<br>
元组比较适合临时组织值，不适合创建复杂的数据结构。</p>
<div class="highlight"><pre><code class="python"><span class="n">let</span> <span class="n">http404Error</span> <span class="o">=</span> <span class="p">(</span><span class="mi">404</span><span class="p">,</span> <span class="s">&quot;Not Found&quot;</span><span class="p">)</span> <span class="o">//</span> <span class="err">类型是</span><span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>

<span class="o">//</span> <span class="err">获取其中的值</span>
<span class="n">let</span> <span class="p">(</span><span class="n">statusCode</span><span class="p">,</span> <span class="n">statusMessage</span><span class="p">)</span> <span class="o">=</span> <span class="n">http404Error</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;The status code is \(statusCode), message is \(statusMessage)&quot;</span><span class="p">)</span>
<span class="o">//</span> <span class="err">只获取关心的值</span>
<span class="n">let</span> <span class="p">(</span><span class="n">justTheStatusCode</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">http404Error</span>
<span class="o">//</span> <span class="err">通过下标获取对应的值，从零开始</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;The status code is \(http404Error.0), message is \(http404Error.1)&quot;</span><span class="p">)</span>

<span class="o">//</span> <span class="err">元组定义时可以给其中的元素命名</span>
<span class="n">let</span> <span class="n">http200Status</span> <span class="o">=</span> <span class="p">(</span><span class="n">statusCode</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="s">&quot;OK&quot;</span><span class="p">)</span>
<span class="o">//</span> <span class="err">有名字后可以通过名字访问</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;The status code is \(http200Status.statusCode), message is \(http200Status.description)&quot;</span><span class="p">)</span>
</code></pre></div>
<h2 id="枚举">枚举</h2>

<p>Swift中，枚举是一等（first-class）类型，不同于C语言中枚举是一组整型值。所以Fruit.Apple并不对应任何值。<br>
使用枚举时，如果类型已知，可以直接通过.Apple这种方式来使用；如果类型未知，通过全名Fruit.Apple来使用。
&ldquo;` python
enum Fruit {
    case Apple, Banana
    case Orange</p>
<div class="highlight"><pre><code class="text">func toString() -&gt; String {
    switch (self) {
        case .Apple:
            return &quot;Apple&quot;
        case .Orange:
            return &quot;Orange&quot;
        case .Banana:
            return &quot;Banana&quot;
        default:
            return &quot;Unkown&quot;
    }
}
</code></pre></div>
<p>}
// usage
var something = Fruit.Apple
something = .Banana
&rdquo;`</p>

<p>枚举的特点在于可以关联原始值或实例值。不关联、原始值、实例值只能取其一，即关联了原始值就不能再关联实例值。</p>

<p>原始值对所有枚举的实例都是相同的。原始值工作的像C++、Java等语言的枚举值一样。
原始值可以是字符串，字符，或者任何整型值或浮点型值。每个原始值在它的枚举声明中必须是唯一的。
关联原始值后，枚举可以通过toRaw()得到原始值，通过frowRaw()创建枚举值。如果传给frowRaw()的值未在枚举中定义，会返回nil。
&ldquo;` python
enum Fruit:Double {
    case Apple = 7
    case Orange, Banana, Peach
}</p>

<p>var value = Fruit.Orange
value.toRaw()                       // 8.0
var outOfRange = Fruit.fromRaw(3.0) // 返回值为nil
outOfRange?.toRaw()                 // 返回值为nil</p>
<div class="highlight"><pre><code class="text">枚举关联实例值时，可以将枚举想象为一个容器，里面可以装一个或多个值，这些值是在创建实例时放进去的，不同的实例放的值不同。
``` python
enum Fruit {
    case Apple(String, String)
    case Orange(String), Banana(Int), Peach
}

let apple = Fruit.Apple(&quot;Price:32&quot;,&quot;Size:4&quot;)
switch(apple) {
    case let .Apple(price, size):
        println(&quot;Info: \(price), \(size)&quot;)
    case .Orange:
        println(&quot;orange&quot;)
    default:
        println(&quot;default&quot;)
}
</code></pre></div>
<h2 id="泛型">泛型</h2>

<p>泛型可用于函数、类、枚举和结构体。
<code>python
func repeat&lt;ItemType&gt;(item: ItemType, times: Int) -&gt; ItemType[] {
    var result = ItemType[]()
    for i in 0..times {
        result += item 
    }
    return result
}
// usage
repeat(&quot;knock&quot;, 4)
</code>
可以在类型后面使用where来指定一个需求列表
<code>python
class SomeClass &lt;T, U where T: Sequence, U: Sequence,
                    T.GeneratorType.Element: Equatable,
                    T.GeneratorType.Element == U.GeneratorType.Element&gt; {
    // more def here
}
</code></p>

<p>在限制条件比较简单的情况下，可以不用where，如<code>&lt;T:Equatable&gt;</code>和<code>&lt;T where T:Equatable&gt;</code>等价。</p>

<h2 id="optional值">Optional值</h2>

<p>Swift中常量（let）定义时必须赋初始值，变量（var）可以不赋值，但需要显示指定类型，如<code>var value : Int</code>。
Swift不自动给变量赋初始值，变量使用前必须初始化。</p>

<p>如果使用时还无法确定初始值，那就需要用到Optional值了，一个未赋值的Optional值会被自动设置为nil。Optional可以通过?来使用。
<code>python
// 声明Optional值变量
var shape:Shape? = nil
// 对Optional值操作时，需要做空值判断，判断是否能响应后面的操作。
// 如果shape为nil，则?之后的被忽略，返回nil；否则执行?后的代码
let value = shape?.num
</code>
函数的返回值也可以是Optional值，即可能返回nil
<code>python
func getSomeValue() -&gt; Int? {
    return nil
}
</code>
实际上，Optional是个enum，其中定义了None和Some两种类型。nil就等价于Optional.None。所以在使用Optional值时，如调用方法、属性、下标索引等，必须在Optional值后面加?来使用，不然会有语法错误。?是Optional定义的一种快捷的拆包方式。Optional的定义如下：
&rdquo;` python
enum Optional<T> : LogicValue, Reflectable { 
    case None 
    case Some(T) 
    init() 
    init(_ some: T) </p>
<div class="highlight"><pre><code class="text">/// Allow use in a Boolean context. 
func getLogicValue() -&gt; Bool 

/// Haskell&#39;s fmap, which was mis-named 
func map&lt;U&gt;(f: (T) -&gt; U) -&gt; U? 
func getMirror() -&gt; Mirror 
</code></pre></div>
<p>}
&ldquo;`
那除了后面加?之外，还有没有别的拆包方法呢？有的，有两种：</p>

<ol>
<li>Optional Binding，可以用在if和while语句中
<code>python
var value : String?
if let tmp = value {
let hashStr = tmp.hashValue
}
</code></li>
<li>后面加!号，表示确定非nil，强制拆包。当然，如果是nil的话会crash
<code>python
var value : String?
value!.hashValue
</code>
哇！还有一个!号，对，!号还有一个用法，就是用来声明隐式拆包的Optional
（Implicitly Unwrapped Optionals），这样对变量操作时，会自动补上一个!进行拆包。当然，自己补上!?也是可以的。
<code>python
var value : String!
value.hashValue // 语法OK，但是会crash
value!.hashValue // 语法OK，但是会crash
value?.hashValue // 语法OK，不会crash
</code>
Optional是够复杂的，把整个Swift语法简洁漂亮的美好形象都打破了，有没有？好吧，我保证这绝对是本文里面语法最复杂的部分了，后面不再会超出你的想像了。来个测试试试看，下面这段代码会打印出啥？答案在<a href="#answer">最下方</a>
<code>python
let optval: Bool? = false
if optval               { println(&quot;1&quot;) }
if optval!              { println(&quot;2&quot;) }
if optval == true       { println(&quot;3&quot;) }
if optval! == true      { println(&quot;4&quot;) }
if optval == false      { println(&quot;5&quot;) }
if optval! == false     { println(&quot;6&quot;) }
</code></li>
</ol>

<h2 id="流控制">流控制</h2>

<p>switch case的语法特别丰富。一个case可以匹配多个模式，用逗号分开；也可以匹配范围。
<code>python
switch count {
    case 0:
        str = &quot;no&quot;
    case 1, 2, 3:
        str = &quot;a few&quot;
    case 4...100:
        str = &quot;a lot of&quot;
    default:
        str = &quot;too many&quot;
}
</code></p>

<p>switch也可以匹配元组；可以值绑定（Value Bindings）；可以通过where添加额外判断条件。
&rdquo;` python
let somePoint = (1, 1)
switch somePoint {
    case (0, 0):
        str = &ldquo;at the origin&rdquo;
    case (_, 0):
        str = &ldquo;on the x-axis&rdquo;
    case (-2&hellip;2, -2&hellip;2):
        str = &ldquo;inside the box&rdquo;
    case (0, let y):
        str = &ldquo;on the y-axis, and y = (y)&rdquo;
    case var (x, y) where x == y:
        str = &ldquo;on the line at ((x), (y))&rdquo;
    default:
        str = &ldquo;nowhere&rdquo;
}</p>

<p>switch不需要break，执行完一个case后推出整个switch。如果需要C语言中执行完一个case落入下一个case中的情况，需要用到 <strong>fallthrough</strong>。</p>

<p>当多个流控制代码块相互套嵌时，可以通过标签来明确跳出位置。
<code>python
gameLoop: while square != finalSquare {
    if some {
        value = 3
    } else if some == 7 {
        break gameLoop
    }
}
</code></p>
<div class="highlight"><pre><code class="python"><span class="o">//</span> <span class="err">不需要用到循环的值</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">..</span><span class="n">power</span> <span class="p">{</span>
<span class="n">answer</span> <span class="o">*=</span> <span class="n">base</span>
<span class="p">}</span>
<span class="o">//</span> <span class="n">C</span><span class="err">样式的</span><span class="k">for</span><span class="err">循环</span>
<span class="k">for</span> <span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">todo</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="协议和扩展">协议和扩展</h2>

<h3 id="协议/接口">协议/接口</h3>

<p>协议的例子如下，
<code>python
protocol Speak {
    var des: String {get}
    var num: Int {get set}
    mutating func say()
}
// usage
var man : Speak? = nil
</code>
其中，get用于控制访问权限，表明只能获取不能设置；mutating表示say方法可以修改内部内容，
class默认可以修改类，无需声明，struct需要通过mutating声明会修改结构体内容。
协议方法的声明与普通方法声明相似，支持变长参数(variadic parameter)，但不支持默认参数(default parameter)。</p>

<p>类、结构体、枚举都可以实现接口。</p>

<p>协议继承。<br>
能够继承一个或多个其他协议。
<code>python
protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // 协议定义
}
</code></p>

<p>协议合成。<br>
多个协议可以通过<code>protocol&lt;SomeProtocol, AnotherProtocol&gt;</code>合成一个临时协议。协议合成可以用于要求变量、参数遵循合成的协议中的所有协议。
&ldquo;` python
protocol Named {
    var name: String {get}
}
protocol Aged {
    var age: Int {get}
}</p>

<p>func hello(someone:protocol<Named, Aged>) {
    var str = &quot;hello, (someone.name) (someone.age)&rdquo;
    println(str)
}
struct Person {
    var id: protocol<Named, Aged>?
}
&ldquo;`</p>

<p>可选协议。<br>
用@objc前缀来表示协议是可选的，协议中用@optional前缀来定义可选成员。
可选成员只能在@objc前缀的可选协议中生效，且可选协议只能被类（class）遵循。
<code>python
@objc protocol Named {
    var name: String {get}
    @optional var desp: String {get}
}
class Person: Named {
    var name:String = &quot;hello&quot;
}
// usage
var p:Named = Person()
p.name // return &quot;hello&quot;
p.desp // return nil
</code></p>

<h3 id="扩展">扩展</h3>

<p>扩展可以向已有类型添加新功能。可以添加属性、方法、构造器、下标、嵌套类型、实现新接口。
添加扩展后，新功能对已有类型的所有实例都是可用的，包括在这个扩展前定义的。
但是，￼扩展可以添加新的计算属性，不可以添加存储属性，也不可以向已有属性添加属性观测器(property observers)。
扩展的语法如下：
&rdquo;` python
extension SomeType {
    // new functionality
}</p>

<p>extension SomeType: SomeProtocol, AnotherProctocol {
    // new protocol implementation
}
&ldquo;`</p>

<p>扩展Double的例子
&rdquo;` python
extension Double {
    var km: Double { return self * 1_000.0 }
    var m : Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
    // 添加修改实例本身的方法需要标注为mutating
    mutating func square() {
        self = self * self
    }
}</p>

<p>let oneInch = 25.4.mm
let threeFeet = 3.ft
&ldquo;`</p>

<p>可以使用extension让任何现有的类型实现新的protocol，例如让Double类型实现Speak接口。
<code>python
extension Double:Speak {
    var des : String {
        return &quot;Double value&quot;
    }
    func say() {
        println(&quot;\(self.des): \(self)&quot;)
    }
}
// usage
3.2.say()
</code></p>

<h2 id="答案">答案</h2>

<p><a name="answer">答案</a>是会打印出 1 5 6 。可以copy到playground里试试看 ^_^</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift资源汇总]]></title>
    <link href="http://erikge.com/articles/SwiftResSummary"/>
    <updated>2014-06-20T15:54:19+08:00</updated>
    <id>http://erikge.com/articles/SwiftResSummary</id>
    <content type="html"><![CDATA[<p>最近iOS的开发世界里最热的应该就是Swift了。Swift让大家再次站在了同一起跑线上，而且是那么酷的脚本语言的语法。<br>
经过这不到一个月的时间，Swift的相关教程、资源、论坛蓬勃而出。就像美剧养肥了再看一样，汇总一些养肥的资源。</p>

<!--more-->

<h2 id="教程">教程</h2>

<ul>
<li><a href="http://kc.cc/VWs5">The Swift Programming Language中文完整版（CocoaChina精校）</a></li>
<li><a href="http://numbbbbb.gitbooks.io/-the-swift-programming-language-/">github上的翻译项目，网友力量的再一次体现</a>，离线<a href="https://www.gitbook.io/download/pdf/book/numbbbbb/-the-swift-programming-language-?lang=">pdf版</a></li>
</ul>

<h2 id="热闹的论坛">热闹的论坛</h2>

<ul>
<li><a href="http://swiftist.org/">http://swiftist.org/</a></li>
<li><a href="http://www.cocoachina.com/bbs/thread.php?fid=57">CocoaChina交流区</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开始iOS开发]]></title>
    <link href="http://erikge.com/articles/SetupEnvironment"/>
    <updated>2014-03-12T16:04:53+08:00</updated>
    <id>http://erikge.com/articles/SetupEnvironment</id>
    <content type="html"><![CDATA[<p>简要列出快速上手开发iOS程序需要做得事项，以便于在心中有一个整体估计。本文尽量作为一个避免细节的梗概。</p>

<!--more-->

<h2 id="开发环境">开发环境</h2>

<p>搭建开发环境，基本上就是安装各种工具软件。</p>

<ol>
<li>xcode安装

<ul>
<li>AppStore中下载安装xcode程序</li>
<li>安装command line tools。xcode5中不再提供下载，需要从<a href="https://developer.apple.com/downloads/index.action">Apple Developer Tools site</a>下载，或者通过命令行运行<code>xcode-select --install</code>下载安装</li>
<li>第一次在xcode运行程序时，enable developer mode，输入本机密码</li>
<li>在xcode中下载开发文档</li>
</ul></li>
<li>真机调试（如果加入苹果开发者计划，并且是Agent、Admin，如下自动化操作最省事）

<ul>
<li><code>Xcode-&gt;Preferences-&gt;Account</code>添加自己的账号，<code>View Details</code>刷新Provisioning Profiles</li>
<li>插入iphone设备，选择信任</li>
<li>运行程序，出现签名错误，选择自动Fix Issue；出现证书问题，选择自动Fix Issue</li>
<li>（可选）可以导出account备份，下次换机器就不用再重复上述第1、3步</li>
</ul></li>
<li>JDK安装</li>
<li>source tree安装，便于git做代码管理</li>
<li>Homebrew安装，便于安装各种命令行工具

<ul>
<li><code>ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)”</code></li>
<li>You should run <code>brew doctor</code> <em>before</em> you install anything.</li>
</ul></li>
<li>SlickEdit安装，非常好用的IDE，需要写c、cpp代码必备</li>
</ol>

<h2 id="处理器架构">处理器架构</h2>

<p>到目前为止，iOS设备采用的都是arm架构的处理器，使用arm指令集；模拟器运行在intel芯片的mac机上，采用的是x86架构，使用x86指令集，对应的编译选项是i386。armv6, armv7等实质上是arm指令集的不同版本，原则上是向下兼容的，例如支持armv7的cpu可以运行armv7选项编译出的程序，也可以运行armv6选项编译出的程序。</p>

<p>已有的iOS设备和arm指令集版本对应关系如下：</p>

<table><thead>
<tr>
<th>指令集版本</th>
<th>iOS设备</th>
</tr>
</thead><tbody>
<tr>
<td>armv6</td>
<td>iPhone，iPhone2，iPhone 3G，第一代、第二代iPod Touch</td>
</tr>
<tr>
<td>armv7</td>
<td>iPhone 3GS,iPhone 4,iPhone 4S，iPad，iPad 2，the new iPad，iPod Touch 3G，iPod Touch 4</td>
</tr>
<tr>
<td>armv7s</td>
<td>iPhone 5</td>
</tr>
<tr>
<td>arm64</td>
<td>iphone 5s，iPad mini 2，iPad Air</td>
</tr>
</tbody></table>

<p>xcode可以把不同指令集编译的版本都打包到同一程序中，这样在不同的设备上就可以自动选择最佳的指令集编译版本，缺点就是体积大点儿。可以根据想支持的iOS设备的多少设置工程Build Setting的Architectures中的<code>Build Active Architecture Only</code>和<code>Architectures</code>，<code>Valid Architectures</code>。</p>
]]></content>
  </entry>
  
</feed>
